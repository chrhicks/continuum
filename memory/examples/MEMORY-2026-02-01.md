---
consolidation_date: 2026-02-01T11:45:00Z
source_sessions: [sess_abc120, sess_abc121, sess_abc122, sess_abc123]
total_sessions_consolidated: 4
tags: [auth, bugfix, api, middleware, testing]
consolidated_by: skill_memory_manager_v0.1
notes: User-triggered consolidation after auth bugfix completion
---

# February 2026 Consolidated Memory

## Auth Architecture Decision

**Date Range**: 2026-01-28 to 2026-02-01
**Session Count**: 4 sessions (tkt_auth_456, tkt_bug_789, related work)
**Status**: IMPLEMENTED & TESTED

### Summary
After investigating JWT authentication challenges and discovering a critical timezone handling bug, we implemented a cookie-based authentication solution with proper UTC normalization. The decision was driven by:

1. **JWT Complexity**: Token refresh flow added significant complexity to our SSR setup
2. **Library Bug**: JWT library v3.2 has timezone handling issues (see Technical Discovery below)
3. **Simplicity**: Cookie-based auth with httpOnly, secure flags provides adequate security with simpler implementation

### Implementation Details

**Files Modified**:
- `src/auth/middleware.ts` - Rewrote auth validation logic
- `test/auth-timezone.test.ts` - Added comprehensive timezone test cases
- `opencode.json` - Updated session configuration

**Key Changes**:
```typescript
// Before: JWT timezone bug on line 45
const decoded = jwt.verify(token, secret);

// After: Cookie-based with UTC normalization
const sessionId = req.cookies.sessionId;
const session = await validateSession(sessionId, { timezone: 'UTC' });
```

**Performance Impact**:
- Auth validation: +2ms per request (acceptable)
- Session storage: Using Redis, 99.9% hit rate
- No measurable impact on overall API latency

### Related Work

**Created Tasks**:
- tkt_rate_890 - API rate limiting (recognized as separate concern)

**Prerequisites Met**:
- [x] Authentication middleware rewritten
- [x] Comprehensive test coverage (95%)
- [x] Documentation updated in `docs/auth.md`
- [x] Security review completed
- [x] Performance benchmarks recorded

### Technical Discovery: JWT Timezone Bug

**Context**: While debugging auth failures from users in different timezones, we discovered the JWT library v3.2 does not properly handle timezone offsets in token expiration checks.

**Symptoms**:
```
Error: Token expired (though it's valid for another 2 hours)
Affected users: UTC+8, UTC-5, UTC+3
```

**Root Cause**: Library compares local time vs UTC without proper offset handling.

**Workaround Implemented**:
```typescript
// Normalize both times to UTC before comparison
const exp = decoded.exp * 1000; // JWT uses seconds
const now = Date.now(); // Already UTC
if (now > exp) { /* expired */ }
```

**Impact**: Solved immediate auth issues for 15% of user base
**Follow-up**: Reported bug to library maintainers, tracking in tkt_bug_101

**Test Case**:
```typescript
test('auth with timezone +8', async () => {
  const token = createToken({ exp: Date.now() + 3600, timezone: '+8' });
  const req = mockRequestWithTimezone('+8');
  await expect(validateAuth(token, req)).resolves.toBeTruthy();
});
```

## Rate Limiting Pattern

**Date**: 2026-01-31
**Session**: sess_abc122 ( afternoon session )
**Status**: IMPLEMENTED

### Summary
While working on authentication, recognized need for API rate limiting to prevent abuse. Implemented sliding window rate limiter with Redis backend.

### Implementation

**Location**: `src/middleware/rate-limit.ts`

**Configuration**:
```typescript
const limiter = createRateLimiter({
  windowMs: 60 * 1000,  // 1 minute
  max: 60,              // 60 requests per window per IP
  store: new RedisStore({ client: redis }),
  keyGenerator: (req) => req.ip
});
```

**Performance**:
- Custom implementation: 40% faster than express-rate-limit
- Memory usage: 2MB per 1000 active IPs
- Redis latency: <1ms average

**Testing**: 1000 concurrent requests, 0 false positives

### Relationship to Auth

Rate limiting complements authentication:
- Even authenticated users are rate limited
- Different limits for different auth levels (user vs admin)
- Rate limiter runs before auth to prevent DDoS on auth endpoint

### Follow-up Tasks

1. [x] tkt_rate_890 - Basic rate limiting (completed)
2. [ ] tkt_rate_891 - WebSocket rate limiting (future)
3. [ ] tkt_rate_892 - Per-user limiting (not just per-IP)

## Middleware Strategy Evolution

**Time Period**: January 2026
**Sessions**: Multiple (auth, rate limiting, error handling work)

### Pattern Established

**Execution Order** (critical!):
1. `rateLimit()` - Prevent DDoS
2. `authenticate()` - Verify identity
3. `authorize()` - Check permissions
4. `validate()` - Validate input
5. `handler()` - Process request

**Error Handling**:
```typescript
// Global error handler catches all middleware errors
app.use((err, req, res, next) => {
  logger.error(err);
  res.status(err.status || 500).json({
    error: process.env.NODE_ENV === 'production' 
      ? 'Internal error' 
      : err.message
  });
});
```

**Benefits Observed**:
- Clear separation of concerns
- Reusable middleware across routes
- Centralized error handling
- Easy to test individually

### Files
- `src/middleware/index.ts` - Middleware composition
- `src/middleware/rate-limit.ts` - Rate limiting
- `src/middleware/auth.ts` - Authentication
- `src/middleware/error.ts` - Error handling
